#Memory

## Bit / Byte
메모리는 0과 1을 저장할 수 있는 반도체이며, 전압 차이를 이용하여 데이터를 저장한다. 전기가 들어오면 1, 그렇지 않으면 0이 저장된다.
0이나 1을 저장할 수 있는 가장 작은 공간을 Bit 라고 한다. 여기에 저장되는 모든 데이터는 종류에 관계 없이 모두 2진수로 변환되어 저장된다.
8개의 Bit 가 모이면 Byte 가 된다. 1Byte에는 얼마만큼의 값을 저장할 수 있을까?
1Bit에는 0과 1을 저장할 수 있다.
2Bit에는 0과 1의 조합 4개를 저장할 수 있다. (2^2)
1Byte에는 2^8 로 256개의 패턴을 저장할 수 있다. 양수만 저장할 수 있다고 한다면 나타낼 수 있는 수는 0부터 255까지를 저장할 수 있다. 
양수와 음수를 모두 저장한다고 한다면 -128 부터 127까지의 값을 저장할 수 있다.

1Byte 메모리에 양수 22를 저장한다면...
00010110 과 같이 저장된다.

### Bit의 구조
가장 왼쪽에 있는 Bit를 최상위비트, MSB(Most Significant Bit)라고 하고
가장 오른쪽에 있는 Bit를 최하위비트, LSB(Least Significant Bit)라고 한다.
실제 데이터를 저장하는 Bit 를 Data Bit 라고 하는데
양수만 저장할 때에는 모든 Bit 를 Data Bit로 사용한다.

### Sign Bit
컴퓨터는 음수를 있는 그대로 저장할 수 없다. 대부분의 컴퓨터는 최상위 비트를 이용하여 음수와 양수를 표현한다.
MSB가 0이면 Positive Number를 의미하고, 1이면 Negative Number를 의미한다.
이런 역할을 하는 Bit를 Sign Bit라고 한다. 
하나의 비트를 부호 비트로 사용하기 때문에, 실제 데이터를 저장하는 데이터 비트가 하나 줄어들게 되고 값을 저장하는 범위가 달라지게 된다.

### 2's Complement
초창기 컴퓨터는 음수를 저장하기 위해 부호비트를 1로 바꾸고 나머지 비트는 양수와 동일한 방식으로 저장했는데 많은 문제가 발생하였다.
그래서 현재는 2의 보수방식을 사용한다.
이 방식은 양수의 Bit 값을 bitwise not 연산을 하고 1을 더하여 음수를 표현한다.
bitwise not 연산은 bit가 1인 경우 0으로 바꾸고, 0인 경우 1로 바꾸는 연산을 의미한다.

00010110 을 2의 보수방식으로 나타낸다면 다음과 같다.
<pre><code>11101001 <- (1) 00010110에 Bitwise not 연산을 한다
11101010 <- (2) (1)에 +1 한다</pre></code>

따라서 -22는 11101010이 된다. 
최상위비트는 마이너스를 나타내는 1이 되고, 나머지 7개 비트는 Data Bit로 사용된다.

### 메모리의 크기
<pre><code>Bit -> 8Bit == Byte -> 1024Byte == Kilobyte -> 1024Kilobyte == Megabyte
1024Megabyte == Gigabyte -> 1024Gigabyte == Terabyte -> 1024Terabyte == Petabyte
1024Petabyte == Exabyte -> 1024Exabyte == Zettabyte -> 1024Zettabyte == Yottabyte</pre></code>

### 메모리 주소
메모리에는 1Byte 를 저장할 수 있는 공간마다 고유한 주소가 할당되어 있다.
CPU는 이 주소를 통해서 메모리에 접근한다. 
CPU는 메모리 주소를 저장하고 특정 위치에 접근하기 위해서 Memory Address Register 를 사용한다. 
주소 레지스터의 크기는 CPU의 Bit수와 같다.
32bit CPU에서는 주소 레지스터를 통해 약 42억개(4,294,967,296)의 레지스터에 접근할 수 있다.
이를 GB로 환산하면 4GB이다. 
32Bit를 사용하는 컴퓨터의 최대 메모리 영역이 4GB인 이유는 이 때문이다.
64Bit CPU는 단순히 두 배가 아니라 이론적으로는 46,744,073,709,551,616개의 레지스터의 접근할 수 있다. 
사용가능한 최대 메모리 영역은 16EB(Exabyte)이다.
실제로는 운영체제의 메모리 관리 방식에 따라서 더 작은 크기로 제한된다.

### 메모리 공간 분류
운영체제는 프로그램을 실행할 때 마다 프로그램이 사용할 메모리 공간을 할당한다.
이 공간은 사용 용도에 따라 크게 아래의 네 가지로 나누어진다.

* *Code*
 기계어로 번역된 프로그램 코드가 저장된다.
* *Data*
 정적 변수와 전역 변수가 저장된다. 여기에 저장된 데이터는 프로그램이 실행될 때 생성되었다가 프로그램이 종료되면 제거된다. 
* *Heap*
 동적으로 할당된 데이터가 저장된다. 다른 영역은 할당 할 공간의 영역을 예측할 수 있지만, 
 Heap은 동적으로 할당되기 때문에 이 영역을 예측할 수 없다. 
 여기에 저장된 데이터는 생성과 제거시점이 정해져있지 않다. 따라서 코드를 통해 직접 생성 및 제거해주어야 한다.
 더 이상 필요하지 않는 데이터를 제거하지 않고 그대로 둔다면, 프로그램이 종료될 때 까지 유지되고 이런 메모리가 많아지면 결국 메모리가 부족해진다.
 이를 Memory Leaks 라 한다.
* *Stack*
 지역변수, 파라미터, 리턴 값 등이 저장된다. 
 스택은 함수 호출과 밀접한 관련이 있다.
 함수를 호출하면 함수에서 사용하는 모든 값을 저장하는 메모리 공간이 생성된다. 이 공간을 Stack frame이라고 한다.
 Stack frame은 함수 실행이 종료되면 스택에서 제거되고 다른 함수에서 메모리를 사용할 수 있게 된다.
 스택은 Last in first out 방식을 따른다. 함수가 실행 될 때 마다 새로운 스택 프레임이 되고, 함수 실행이 종료되면 가장 최근에 실행 된 스택 프레임부터 제거된다.
 
값 형식(Value Type)은 Stack에 저장된다. 더이상 사용되지 않는 경우 자동으로 제거되기 때문에 메모리 관리가 상대적으로 쉽다.
반면 참조 형식(Reference Type)은 실제 값을 Heap에 저장하고 힙 메모리 주소를 스택에 저장한다. 실제 값에 접근할 때는 항상 스택에 있는 주소를 통해 접근한다. 
값을 더 이상 사용하지 않는다면 두 공간에 저장되어 있는 데이터를 완전히 삭제하여 메모리 누수를 방지하는 것이 중요하다. 
 















